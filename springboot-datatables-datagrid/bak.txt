http://www.cnblogs.com/hooray/archive/2012/09/05/2672133.html
https://www.cnblogs.com/sz-zzm/p/5218696.html
	
java 项目日志管理设计方案
https://blog.csdn.net/jlh912008548/article/details/72782241

springboot整合Quartz实现动态配置定时任务,不用了
https://blog.csdn.net/liuchuanhong1/article/details/60873295

Spring Boot配置定时任务（实例）
https://blog.csdn.net/m0_37885618/article/details/77196691

联想功能添加div

自动化测试工具
https://blog.csdn.net/jlh912008548/article/details/72782241

无注解的官方样例
https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples

小马哥的lesson
https://github.com/mercyblitz/segmentfault-lessons

Git Extensions安装
http://www.opdown.com/soft/79790.html#download

(1)日志组件和选择
https://blog.csdn.net/duguxiaobiao/article/details/78988409


(1)sql根据某一个字段重复只取第一条数据
https://zhidao.baidu.com/question/1367499739240602099.html
使用分析函数row_number() over (partiion by ... order by ...)来进行分组编号，然后取分组标号值为1的记录即可。目前主流的数据库都有支持分析函数，很好用。
其中，partition by 是指定按哪些字段进行分组，这些字段值相同的记录将在一起编号；order by则是指定在同一组中进行编号时是按照怎样的顺序。
示例(SQL Server 2005或以上适用)：
select s.*   
from (  
    select *, row_number() over (partition by [手机号] order by [店铺]) as group_idx   
    from table_name 
) s 
where s.group_idx = 1


（1）
tomcat 配置
clean package -Dmaven.test.skip=true -Psit
edit configurations->+>tomcat server->local->+->Run Maven Goal->Command line -> clean package -Dmaven.test.skip=true -Psit
Deployment->rd-search:war exploded->Application context: /rd-search

（1）redis service参照
1）OffsetCacheItemVo.java
/**
 * 偏移量缓存Vo
 *
 */
public class OffsetCacheItemVo
{
    private int offset;

    private String source;

    /**
     * xxx
     * @return String
     */
    public String getSource()
    {
        return source;
    }

    /**
     * xx
     * @param source String
     */
    public void setSource(String source)
    {
        this.source = source;
    }

    /**
     * xx
     * @return int
     */
    public int getOffset()
    {
        return offset;
    }

    /**
     * xx
     * @param offset int
     */
    public void setOffset(int offset)
    {
        this.offset = offset;
    }
}

2) OffsetCacheVo.java

import java.util.ArrayList;
import java.util.List;

public class OffsetCacheVo {

    private Integer pageIndex;

    private List<String> idList;

    private List<OffsetCacheItemVo> cacheItem = new ArrayList<>();

    /**
     * 获取IDList
     * @return List<String>
     */
    public List<String> getIdList()
    {
        return idList;
    }

    /**
     * 设置IDList
     * @param idList List<String>
     */
    public void setIdList(List<String> idList)
    {
        this.idList = idList;
    }

    /**
     * 获取缓存条目
     * @return List<OffsetCacheItemVo>
     */
    public List<OffsetCacheItemVo> getCacheItem()
    {
        return cacheItem;
    }

    /**
     * 设置缓存条目
     * @param cacheItem List<OffsetCacheItemVo>
     */
    public void setCacheItem(List<OffsetCacheItemVo> cacheItem)
    {
        this.cacheItem = cacheItem;
    }

    /**
     * 获取分页页码
     * @return Integer
     */
    public Integer getPageIndex()
    {
        return pageIndex;
    }

    /**
     * 设置分页页码
     * @param pageIndex Integer
     */
    public void setPageIndex(Integer pageIndex)
    {
        this.pageIndex = pageIndex;
    }
}

3）RedisService.java

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.data.redis.connection.RedisConnection;
import org.springframework.data.redis.core.RedisCallback;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;


/**
 *
 *
 */
@Service("redisService")
public class RedisService 
{
    @SuppressWarnings("rawtypes")
    @Autowired(required = false)
    RedisTemplate redisTemplate;
    
    /**
     * redis写入
     * @param key String
     * @param value String
     */
    @SuppressWarnings("unchecked")
    public void set(String key, String value)
    {
        redisTemplate.execute(new RedisCallback<Object>()
        {

            @Override
            public Object doInRedis(RedisConnection connection) throws DataAccessException
            {
                connection.set(redisTemplate.getStringSerializer().serialize(key),
                        redisTemplate.getStringSerializer().serialize(value));
                return null;
            }
            
            
        });
    }

    /**
     * 带过期时间的键值设置
     * @param key String
     * @param value Object
     * @param second Long
     */
    public void set(String key, Object value, Long second) 
    {
        redisTemplate.execute(new RedisCallback<Object>()
        {
            @Override
            public Object doInRedis(RedisConnection connection) throws DataAccessException
            {
                byte[] serializeKey = redisTemplate.getStringSerializer().serialize(key);
                connection.set(serializeKey, redisTemplate.getStringSerializer().serialize(value));
                connection.expire(serializeKey, second);
                return null;
            }
        });
    }



    /**
     * 通过key获取value
     * @param key String
     * @return value
     */
    @SuppressWarnings("unchecked")
    public String get(String key)
    {
        return (String) redisTemplate.execute(new RedisCallback<Object>()
        {

            @Override
            public Object doInRedis(RedisConnection connection) throws DataAccessException
            {
                byte[] byteKey = redisTemplate.getStringSerializer().serialize(key);
                if (connection.exists(byteKey))
                {
                    byte[] byteValue = connection.get(byteKey);
                    String value = (String) redisTemplate.getStringSerializer().deserialize(byteValue);
                    return value;
                }
                return null;
            }
            
        });
    }
    
    /**
     * 按照key执行删除操作
     * @param key string
     */
    @SuppressWarnings("unchecked")
    public void delete(String key)
    {
        redisTemplate.execute(new RedisCallback<Object>()
        {

            @Override
            public Object doInRedis(RedisConnection connection) throws DataAccessException
            {
                connection.del(redisTemplate.getStringSerializer().serialize(key));
                return null;
            }
        });
    }
  

}

4)  CashUtil.java

import com.alibaba.fastjson.JSONObject;
import org.apache.commons.collections.CollectionUtils;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class CashUtil {
    /**
     * 读缓存
     *
     * @param key
     *            String
     * @return Map<Integer, OffsetCacheVo>
     */
    public static Map<Integer, OffsetCacheVo> readCache(String key)
    {
        RedisService redisService = (RedisService)ApplicationContextUtil.getApplicationContext().getBean("redisService");
        String jasonArray = redisService.get(key);
        List<OffsetCacheVo> resources = JSONObject.parseArray(jasonArray, OffsetCacheVo.class);
        Map<Integer, OffsetCacheVo> pair = new HashMap<>();
        if (CollectionUtils.isNotEmpty(resources))
        {
            for (OffsetCacheVo resource : resources)
            {
                pair.put(resource.getPageIndex(), resource);
            }
        }
        return pair;
    }

    /**
     * 写缓存
     *
     * @param key
     *            String
     * @param data
     *            List<OffsetCacheVo>
     */
    public static void writeCache(String key, List<OffsetCacheVo> data)
    {
        Map<Integer, OffsetCacheVo> cache = readCache(key);
        for (OffsetCacheVo resource : data)
        {
            cache.put(resource.getPageIndex(), resource);
        }
        RedisService redisService = (RedisService)ApplicationContextUtil.getApplicationContext().getBean("redisService");
        String continueTime = "30";
        redisService.set(key, JSONObject.toJSONString(cache.values()), Integer.parseInt(continueTime) * 60L);
    }
}

5) ApplicationContextUtil.java

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;

@Component
public class ApplicationContextUtil implements ApplicationContextAware 
{
    private static ApplicationContext context;

    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        context = applicationContext;
    }
    
    public static ApplicationContext getApplicationContext() {
        return context;
    }
}

6) Test.java

import com.google.common.collect.Lists;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class Test {
    public static void test(){
        Integer pageIndex = 1;
        List<String> idList = new ArrayList<>(16);
        for (int i = 0; i < 5; i++) {
            idList.add("dbox_"+(i+1));
        }
        OffsetCacheItemVo cacheItem = new OffsetCacheItemVo();
        cacheItem.setOffset(idList.size());
        cacheItem.setSource("dbox");
        OffsetCacheVo offsetCache = new OffsetCacheVo();

        offsetCache.setPageIndex(pageIndex);
        offsetCache.setIdList(idList);
        offsetCache.getCacheItem().add(cacheItem);

        // 写缓存
        CashUtil.writeCache("dbox_asdfghijklmn", Lists.newArrayList(offsetCache));
        Map<Integer, OffsetCacheVo> cash =  CashUtil.readCache("dbox_asdfghijklmn");
        System.out.println("hello");
    }
}

(1) 异步任务
1) AsyncUtil.java
import com.google.common.util.concurrent.ThreadFactoryBuilder;

import java.time.Duration;
import java.util.concurrent.*;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 * 用于异步调度的工具类
 *
 */
public final class AsyncUtil
{
    private static final ScheduledExecutorService SCHEDULER = Executors.newScheduledThreadPool(1,
            new ThreadFactoryBuilder().setDaemon(true).setNameFormat("failAfter-%d").build());

    private AsyncUtil()
    {
    }

    /**
     * <一句话功能简述> <功能详细描述>
     * 
     * @param duration
     * @return
     */
    private static <T> CompletableFuture<T> failAfter(Duration duration)
    {
        final CompletableFuture<T> promise = new CompletableFuture<>();
        SCHEDULER.schedule(() ->
        {
            final TimeoutException ex = new TimeoutException("Timeout after " + duration);
            return promise.completeExceptionally(ex);
        }, duration.toMillis(), TimeUnit.MILLISECONDS);
        return promise;
    }

    /**
     * 异步执行任务，并设置超时
     * 
     * @param future
     *            待执行的异步任务结果
     * @param duration
     *            超时时间
     * @param <T>
     *            <T>
     * @return CompletableFuture
     */
    public static <T> CompletableFuture<T> within(CompletableFuture<T> future, Duration duration)
    {
        final CompletableFuture<T> timeout = failAfter(duration);
        return future.applyToEither(timeout, Function.identity());
    }

    /**
     * 异步执行任务，并设置超时
     * 
     * @param supplier
     *            异步的labda表达式
     * @param duration
     *            超时时间
     * @param <T>
     *            <T>
     * @return CompletableFuture
     */
    public static <T> CompletableFuture<T> within(Supplier<T> supplier, Duration duration)
    {
        return within(CompletableFuture.supplyAsync(supplier), duration);
    }

    /**
     * 完整的异步回调函数，包括超时、异常处理及回调
     * 
     * @param supplier
     *            异步任务
     * @param duration
     *            超时时间
     * @param fn
     *            异常处理
     * @param action
     *            回调任务
     * @param <T>
     *            <T>
     */
    public static <T> void asyncCallBack(Supplier<T> supplier, Duration duration, Function<Throwable, ? extends T> fn,
            Consumer< ? super T> action)
    {
        within(supplier, duration).exceptionally(fn).thenAccept(action);
    }
}

2) BaseSyncTask.java
import java.time.Duration;
import java.util.concurrent.CountDownLatch;

/**
 * 异步任务基础类
 *
 */
public abstract class BaseSyncTask
{

    private Duration timeout;

    private CountDownLatch latch;

    /**
     *  执行任务
     */
    public abstract void process();

    /**
     * 获取锁
     * @return CountDownLatch
     */
    public CountDownLatch getLatch()
    {
        return latch;
    }

    /**
     * 设置锁
     * @param latch
     */
    public void setLatch(CountDownLatch latch)
    {
        this.latch = latch;
    }

    /**
     * 获取超时时间
     * @return Duration
     */
    public Duration getTimeout()
    {
        return timeout;
    }

    /**
     *  设置超时时间
     * @param timeout Duration
     */
    public void setTimeout(Duration timeout)
    {
        this.timeout = timeout;
    }
}


3) MultiSearchSyncTask.java

import org.apache.log4j.Logger;

import java.time.Duration;
import java.util.concurrent.CountDownLatch;

/**
 * ES multisearch处理任务
 *
 */
public class MultiSearchSyncTask extends BaseSyncTask
{

    private static final Logger LOG = Logger.getLogger(MultiSearchSyncTask.class);

    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    /**
     *  执行任务
     */
    public void process()
    {
        final Duration timeout = getTimeout();
        final CountDownLatch count = getLatch();
        // 通用
        AsyncUtil.asyncCallBack(() ->
        {
            return name;
        }, timeout, ex ->
        {
            LOG.error("MultiSearchSyncTask error", ex);
            return null;
        }, t ->
        {
            try
            {
                if(t.equals("LiLei"))
                {
                    System.out.println("the name I expect");
                }
                else
                {
                    System.out.println("Not the name I expect");
                }
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
            count.countDown();
        });
    }

}

4) SyncTaskProcessor.java
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;

/**
 * 异步任务处理器
 *
 */
public class SyncTaskProcessor
{
    private final List<BaseSyncTask> taskList = new ArrayList<BaseSyncTask>();

    /**
     * 执行任务
     */
    public void process()
    {
        int taskSize = taskList.size();
        final Duration timeout = Duration.ofSeconds(3000);
        final CountDownLatch countDownLatch = new CountDownLatch(taskSize);
        for (BaseSyncTask task : taskList)
        {
            task.setTimeout(timeout);
            task.setLatch(countDownLatch);
            task.process();
        }

        try
        {
            countDownLatch.await();
        }
        catch (InterruptedException e)
        {
            e.printStackTrace();
        }
    }

    /**
     * 增加任务
     * @param task BaseSyncTask
     */
    public void addTask(BaseSyncTask task)
    {
        taskList.add(task);
    }

}

5) Test.java

public class Test {
    public static void main(String[] args) {
        SyncTaskProcessor taskProcessor = new SyncTaskProcessor();
        MultiSearchSyncTask multiSearchSyncTask = new MultiSearchSyncTask();
        multiSearchSyncTask.setName("hanmeimei");
        taskProcessor.addTask(multiSearchSyncTask);
        taskProcessor.process();
    }
}


(0)
idea设置tomcat启动工程
clean package -Dmaven.test.skip=true -Psit
edit configurations->+>tomcat server->local->+->Run Maven Goal->Command line -> clean package -Dmaven.test.skip=true -Psit
Deployment->rd-search:war exploded->Application context: /rd-search

(0)
idea打开多个工程
File->New->Project from Existing Sources->Select File or Directory to Import
D:\work\zhihuiyun_platform_git\rsearch-platform-usegitcommand-zhengshi\pom.xml

（0）
无法运行main方法解决方案
project structure-> libraries->+号 java->select library files
D:\work\apache-tomcat-8.0.46\lib\servlet-api.jar
即可正常运行main方法

（0）
远程连接神器：MobaXterm
（0）
elasticsearch
ES环境和文档
测试环境head插件：http://10.21.188.108:8080/elasticsearch-head-master/   主要用于集群管理
插件用法：http://mobz.github.io/elasticsearch-head/       https://www.cnblogs.com/xing901022/p/5469338.html
测试环境kibana：http://100.101.238.159:5601/app/kibana#/dev_tools/console?_g=()  主要用于数据管理
插件用法：https://www.elastic.co/guide/cn/kibana/current/getting-started.html

常用ES语法
ES权威指南:       https://www.elastic.co/guide/cn/elasticsearch/guide/current/foreword_id.html
JAVA API：https://endymecy.gitbooks.io/elasticsearch-guide-chinese/content/java-api/README.html 
                  https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high.html 

遍历
https://www.elastic.co/guide/cn/elasticsearch/guide/current/scroll.html

查询id、标题等指定内容精确查询
https://www.elastic.co/guide/cn/elasticsearch/guide/current/_finding_exact_values.html 

建立索引 参考文档
https://www.elastic.co/guide/cn/elasticsearch/guide/current/_creating_an_index.html 

修改文档
https://www.elastic.co/guide/cn/elasticsearch/guide/current/update-doc.html 
覆盖更新，url要包括索引，类型，id
https://www.elastic.co/guide/cn/elasticsearch/guide/current/partial-updates.html 
部分更新

创建/删除文档
https://www.elastic.co/guide/cn/elasticsearch/guide/current/create-doc.html 
https://www.elastic.co/guide/cn/elasticsearch/guide/current/delete-doc.html 

查看分析器结果
https://www.elastic.co/guide/cn/elasticsearch/guide/current/analysis-intro.html 



（0）远程调测
setenv.sh
export CATALINA_OPTS="-server -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8899"

（1）数组转换为list的方法
com.google.common.collect.Lists
List<String> userSelectedList = Lists.newArrayList(selectedFrom);

（2）面试第一个
第一个：
1225：给出alipay_tz_invoke_command会调用到的所有TEE的标准接口。便于严寅辉在所有调用到的TEE标准接口入口和出口加打印，排除TEE标准接口导致data_abort。
1226：从汇编的角度定位导致data_abort的指令地址。
1227：应移动要求画出alipay_tz_invoke_command接口里面所有调用到的标准TEE接口的顺序。
1228、1229：用阿里提供的修改后libalipay.a，以及各种不同的libalipay.a调试指纹注册部分，依然会报出data_abort错误。第一条命令正确返回，第二条命令不能返回。
描述1：要实现指纹注册需要实现阿里提供的alipay_tz_invoke_command这个接口，这个接口会调用TEE的一系列标准接口。
指纹注册的时候alipay_tz_invoke_command会被调用两次，第一次正确返回了，第二次会报data_abort错误
当时为了定位是不是我们提供的tee的标准接口有问题，在TEE标准接口里面进出的地方都加了打印。可以看到成对的打印。看来我们这边是没有问题的
指纹注册也会用到指纹芯片厂商 汇顶提供库文件，和阿里的库文件libalipay.a，我们无法看到他们的代码是如何实现的
对libalipay.a做了反汇编
同时把日志都打开看dump文件，分析堆栈信息，最后死机的时候pc指针是指到了libalipay的一个方法里面的某一条语句
精简描述1：
指纹注册在飞马的几款手机上适配过了。但是在中兴的一款手机上注册总是出问题。后来我这边负责定位这个问题。因为我被派到了客户现场。
指纹注册会调用TEE提供的接口，汇顶提供的接口，和ali提供我们的接口。集成到手机里面汇顶和ali的是以.a的文件提供，我们是已点so的文件提供。最终会被编译成trustzone.bin文件提供给手机。
可能互相会用对方的接口，但都看不到对方的实现
当时先是在在TEE标准接口里面进出的地方都加了打印。可以看到成对的打印。看来我们这边是没有问题的
又相别的版本，把手机里面的日志清空了，同时编译了一个带日志的版本，不停重试注册功能，最后手机死机了生成了一个dump文件，里面打印了一句data_abort 同时附带了堆栈信息pc是指向了一个地址
对ali的.a文件做了反汇编  nm libxxx.a



（3），git操作
git操作
Git日常三板斧- 分支操作
查看本地分支 git branch
查看所有分支(本地以及远程) git branch –a 
创建并切换分支：git checkout –b xxx origin/xxx
切换分支：git checkout xxx

git branch xx创建本地分支
git branch -d 删除分支

git checkout . #本地所有修改的。没有的提交的，都返回到原来的状态
git stash #把所有没有提交的修改暂存到stash里面。可用git stash pop回复。
git reset --hard HASH #返回到某个节点，不保留修改。
git reset --soft HASH #返回到某个节点。保留修改

Git日常三板斧-代码提交
添加至index：git add file，也可以用git add –u，只提交加入版本追踪的文件
提交至本地仓库：git commit –m ‘功能描述’，也可以使用git commit –amend，追加至上一次提交，前提是上一次提交没有push
更新代码：git pull origin branchName 
上一步如有冲突，解决完冲突后从第一步执行一遍，直至没有冲突
推送至远程仓库： git push origin branchName 

git 开发流程
暂存代码：git merge   (注:建议附加选项--squash)
上一步如果有冲突，解决完冲突提交代码

Git使用-代码丢弃、回滚
回滚到workspack:git reset xxx
把改动丢弃:git checkout -- file

Git使用-其他常用命令
git show
git log
git diff

Git 开发流程
master
feature
release
任务开发在feature分支上，开发完毕，从master分支创建release分支，将feature分支合并至release分支，然后发布release分支，完成后，将release分支合并至master分支，同时删除feature分支

有两个分支uat_bjc_1025(合并的分支)  configurablev2_bjc_1024(自己的分支)
uat_bjc_1025是集合了其他代码的分支，一起测试，分开上主干
configurablev2_bjc_1024是我方修改的分支，待提交到主干
正常情况应该先修改configurablev2_bjc_1024,上库之后，merge到uat_bjc_1025

git co和git ci
1），使用场景
在uat_bjc_1025分支上做了修改，还没有提交，想把修改移动到configurablev2_bjc_1024
1，git stash先缓存本地uat_bjc_1025的修改
2，切分支 git checkout configurablev2_bjc_1024,下面缩写
git co configurablev2_bjc_1024
3，拿出之前的缓存数据
git stash pop stash@{0}
4，按照步骤提交该修改到configurablev2_bjc_1024版本
git add -u
git commit -m '混排bug'    //  git ci -m '混排bug'
git pull origin configurablev2_bjc_1024
git push origin configurablev2_bjc_1024
5，切分之再merge 别的分支的代码
git co  uat_bjc_1025
git merge --squash configurablev2_bjc_1024
git add -u
git ci -m '混排bug修复'
git pull origin uat_bjc_1025
git push origin uat_bjc_1025

 906  git st
  907  git stash
  908  git co configurablev2_bjc_1024
  909  git stash pop stash@{0}
  910  git diff
  911  git add -u
  912  git st
  913  git ci -m '混排bug'
  914  git pull origin configurablev2_bjc_1024
  915  gi tst
  916  git st
  917  git push origin configurablev2_bjc_1024
  918  git co  uat_bjc_1025
  919  git merge --squash configurablev2_bjc_1024
  920  git add -u
  921  git st
  922  git ci -m '混排bug修复'
  923  git push origin uat_bjc_1025
  924  git pull origin uat_bjc_1025
  925  git push origin uat_bjc_1025
  926  git st
  927  git co configurablev2_bjc_1024
  928  git add -u
  929  git st
  930  git ci -m  '分页bug修复'
  931  git pull origin configurablev2_bjc_1024
  932  git push origin configurablev2_bjc_1024
  933  git co uat_bjc_1025
  934  git merge --squash configurablev2_bjc_1024
  935  git add -u
  936  git st
  937  git ci -m '分页bug'
  938  给他
  939  his
  940  history



ApplicationContextUtil.java
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;

@Component
public class ApplicationContextUtil implements ApplicationContextAware 
{
    private static ApplicationContext context;

    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        context = applicationContext;
    }
    
    public static ApplicationContext getApplicationContext() {
        return context;
    }
}

ConfLoadUtil.java
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.io.ClassPathResource;

import com.fasterxml.jackson.core.type.TypeReference;
import com.huawei.searchevaluate.models.PriorityNumConfModel;

/**
 * 配置文件加载工具类
 * Created by xWX343760 on 2018/8/25.
 */
public class ConfLoadUtil
{
    private final Logger LOG = LoggerFactory.getLogger(ConfLoadUtil.class);
    
    private final static String PRIORITY_CONF = "static/resources/jsonfiles/record_priority_num_conf.json";
    private final static String WEIGHT_CONF = "static/resources/jsonfiles/record_operation_weight_conf.json";
    
    private List<PriorityNumConfModel> priorityNumConf = new ArrayList<>();
    private Map<String, Integer> operationWeightMap = new HashMap<>();
    private Map<String, String> propertiesConfMap = new HashMap<>();

    private final static ConfLoadUtil confLoadUtil = new ConfLoadUtil();

    private ConfLoadUtil()
    {
        loadJsonConf();
        loadPropertiesConf();
    }

    public void loadJsonConf()
    {
        try
        {
            InputStream inputStream = null;
            ClassPathResource pathResource = new ClassPathResource(PRIORITY_CONF);
            inputStream = pathResource.getInputStream();
            priorityNumConf = JsonUtil.fromJson(inputStream, new TypeReference<List<PriorityNumConfModel>>()
            {
            });
        }
        catch (IllegalArgumentException e)
        {
            LOG.info("parse priority conf file failed since exception:", e);
        }
        catch (IOException e)
        {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        try
        {
            InputStream inputStream = null;
            ClassPathResource pathResource = new ClassPathResource(WEIGHT_CONF);
            inputStream = pathResource.getInputStream();
            operationWeightMap = JsonUtil.fromJson(inputStream, new TypeReference<Map<String, Integer>>()
            {
            });
        }
        catch (IllegalArgumentException e)
        {
            LOG.info("parse weight conf file failed since exception:", e);
        }
        catch (IOException e)
        {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public void loadPropertiesConf()
    {
        this.propertiesConfMap = loadProperties("conf.properties");
    }

    private Map<String, String> loadProperties(String filename)
    {
        Map<String, String> map = new HashMap<String, String>();
        Properties properties = new Properties();
        InputStream is = ConfLoadUtil.class.getClassLoader().getResourceAsStream(filename);
        try
        {
            properties.load(is);
            for (Map.Entry entry : properties.entrySet())
            {
                String key = (String) entry.getKey();
                String value = (String) entry.getValue();
                value = new String(value.getBytes("ISO-8859-1"), "utf-8");
                map.put(key, value);
            }
        }
        catch (Exception e)
        {
            LOG.error("can't load properties: ", e);
        }
        finally
        {
            try
            {
                if (is != null)
                {
                    is.close();
                }
            }
            catch (IOException e)
            {
                LOG.error("close is exception: ", e);
            }
        }
        return map;
    }

    public static ConfLoadUtil getInstance()
    {
        return confLoadUtil;
    }

    public void reloadConf()
    {
        loadJsonConf();
    }

    public List<PriorityNumConfModel> getPriorityNumConf()
    {
        return this.priorityNumConf;
    }

    public Map<String, Integer> getOperationWeightMap()
    {
        return this.operationWeightMap;
    }

    public String getPropertyValueByKey(String key)
    {
        return propertiesConfMap.getOrDefault(key, "");
    }
}

DownloadUtil.java
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.io.ClassPathResource;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.multipart.support.StandardMultipartHttpServletRequest;


/**
 * 下载上传文件工具类
 * @author  lWX458995
 * @version  [版本号, 2018年8月16日]
 * @see  [相关类/方法]
 * @since  [产品/模块版本]
 */
public class DownloadUtil
{
    private static final Logger LOGGER = LoggerFactory.getLogger(DownloadUtil.class);
    
    /**
     * 下载静态资源路径下的模板
     * @param request
     * @param response
     * @param filePath 相对于src/main/resources的路径
     * @param fileName [参数说明]
     * 
     * @return void [返回类型说明]
     * @exception throws [违例类型] [违例说明]
     * @see [类、类#方法、类#成员]
     */
    public static void downloadFileStaticResource(HttpServletRequest request, HttpServletResponse response, String filePath, String fileName)
    {
        BufferedInputStream in = null;
        BufferedOutputStream out = null;
        InputStream inputStream = null;
        try
        {
            ClassPathResource classPathResource = new ClassPathResource(filePath + fileName);
            inputStream = classPathResource.getInputStream();
            response.setContentType("application/x-excel");
            response.setCharacterEncoding("UTF-8");
            response.setHeader("Content-Disposition",
                "attachment;filename=" + new String(fileName.getBytes("gbk"), "iso-8859-1"));
            //response.setHeader("Content-Length", String.valueOf(f.length()));
            in = new BufferedInputStream(inputStream);
            out = new BufferedOutputStream(response.getOutputStream());
            byte[] data = new byte[1024];
            int len = 0;
            while (-1 != (len = in.read(data, 0, data.length)))
            {
                out.write(data, 0, len);
            }
        }
        catch (FileNotFoundException e)
        {
        	LOGGER.error(e.getMessage());
        }
        catch (IOException e)
        {
        	LOGGER.error(e.getMessage());
        }
        finally
        {
        	if(null != inputStream){
        		try {
					inputStream.close();
				} catch (IOException e) {
					LOGGER.error(e.getMessage());
				}
        	}
            IOUtils.closeQuietly(in);
            IOUtils.closeQuietly(out);
        }
    }
    
    /**
     * 下载磁盘路径下的模板
     * @param request
     * @param response
     * @param filePath 绝对路径
     * @param fileName [参数说明]
     * 
     * @return void [返回类型说明]
     * @exception throws [违例类型] [违例说明]
     * @see [类、类#方法、类#成员]
     */
    public static void downloadFile(HttpServletRequest request, HttpServletResponse response,String filePath, String fileName)
    {
        BufferedInputStream in = null;
        BufferedOutputStream out = null;
        try
        {
            File f = new File(filePath+fileName);
            response.setContentType("application/x-excel");
            response.setCharacterEncoding("UTF-8");
            response.setHeader("Content-Disposition",
                "attachment;filename=" + new String(fileName.getBytes("gbk"), "iso-8859-1"));
            response.setHeader("Content-Length", String.valueOf(f.length()));
            in = new BufferedInputStream(new FileInputStream(f));
            out = new BufferedOutputStream(response.getOutputStream());
            byte[] data = new byte[1024];
            int len = 0;
            while (-1 != (len = in.read(data, 0, data.length)))
            {
                out.write(data, 0, len);
            }
        }
        catch (FileNotFoundException e)
        {
            LOGGER.error(e.getMessage());
        }
        catch (IOException e)
        {
            LOGGER.error(e.getMessage());
        }
        finally
        {
            IOUtils.closeQuietly(in);
            IOUtils.closeQuietly(out);
        }
    }
    
    /**
     * 上传文件到指定路径filePath 并命名为fileName,返回新生成的文件路径
     * @param request
     * @param filePath
     * @param fileName [参数说明]
     * 
     * @return void [返回类型说明]
     * @exception throws [违例类型] [违例说明]
     * @see [类、类#方法、类#成员]
     */
    public static String uploadFile(HttpServletRequest request, String filePath, String fileName)
    {
        // TODO Auto-generated method stub
        BufferedInputStream in = null;
        BufferedOutputStream out = null;
        try {
            StandardMultipartHttpServletRequest req = (StandardMultipartHttpServletRequest) request;
            Iterator<String> iterator = req.getFileNames();
            while (iterator.hasNext()) {
                MultipartFile file = req.getFile(iterator.next());          
                in = new BufferedInputStream(file.getInputStream());
                out = new BufferedOutputStream(new FileOutputStream(filePath+fileName));
                byte buffer[] = new byte[1024];
                int len = 0;
                while (-1 != (len = in.read(buffer, 0, buffer.length)))
                {
                    out.write(buffer, 0, len);
                }
            }
        }
        catch (IllegalStateException e)
        {
            LOGGER.error(e.getMessage());
        }
        catch(Exception e) {
            LOGGER.error(e.getMessage());
        }finally {
            IOUtils.closeQuietly(in);
            IOUtils.closeQuietly(out);
        }
		return filePath+fileName;
        
    }
}

ExcelDataUtils.java
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang3.StringUtils;
import org.apache.poi.hssf.usermodel.HSSFCell;
import org.apache.poi.hssf.usermodel.HSSFDateUtil;
import org.apache.poi.hssf.util.HSSFColor;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.xssf.usermodel.XSSFCell;
import org.apache.poi.xssf.usermodel.XSSFCellStyle;
import org.apache.poi.xssf.usermodel.XSSFFont;
import org.apache.poi.xssf.usermodel.XSSFRichTextString;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * 处理excel文档
 * @author  lWX458995
 * @version  [版本号, 2018年4月23日]
 * @see  [相关类/方法]
 * @since  [产品/模块版本]
 */
public class ExcelDataUtils<T>
{
    private static final Logger LOGGER = LoggerFactory.getLogger(ExcelDataUtils.class);
    
    /**
     * 通过Excel文档获取值返回二维数组
     * 
     * @param pathFile
     *            文件路径
     * @return String[][] 二维数组
     */
    public static String[][] getArrFromFileXls(String pathFile, int sheetNumber)
    {
        // 读取字段内容
        /*POIFSFileSystem fs;*/
        XSSFWorkbook wb;
        XSSFSheet sheet;
        XSSFRow row;
        String[][] rs = null;
        InputStream is = null;
        Map<Integer, String> map = new HashMap<Integer, String>();
        String str = "";
        try
        {
            is = new FileInputStream(pathFile);
            /*fs = new POIFSFileSystem(is);*/
            wb = new XSSFWorkbook(is);
            sheet = wb.getSheetAt(sheetNumber);
            int rowNum = sheet.getLastRowNum();
            row = sheet.getRow(0);
            int colNum = row.getPhysicalNumberOfCells();
            // 空数据
            if (rowNum == 0)
            {
                return null;
            }
            
            for (int i = 1; i <= rowNum; i++)
            {
                int a = 0;
                row = sheet.getRow(i);
                while (a < colNum)
                {
                    str += String.valueOf(getCellValue(row.getCell(a)));
                    a++;
                }
                map.put(i, str);
                str = "";
            }
            for (int m = 1; m <= map.size(); m++)
            {
                if (StringUtils.isBlank(map.get(m)))
                {
                    rowNum--;
                }
            }
            rs = new String[rowNum][];
            
            for (int i = 1; i <= rowNum; i++)
            {
                row = sheet.getRow(i);
                rs[i - 1] = new String[colNum];
                
                for (int j = 0; j < colNum; j++)
                {
                    if (!"null".equals(String.valueOf(getCellValue(row.getCell(j))))
                        && !"".equals(String.valueOf(getCellValue(row.getCell(j)))))
                    {
                        rs[i - 1][j] = String.valueOf(getCellValue(row.getCell(j))).trim();
                    }
                    else
                    {
                        rs[i - 1][j] = "";
                    }
                }
            }
        }
        
        catch (FileNotFoundException e)
        {
        	LOGGER.error(e.getMessage());
            return null;
        }
        catch (IOException e)
        {
        	LOGGER.error(e.getMessage());
            return null;
        }
        catch (Exception e)
        {
        	LOGGER.error(e.getMessage());
            return null;
        }
        finally
        {
            if (is != null)
            {
                try
                {
                    is.close();
                }
                catch (IOException e)
                {
                	LOGGER.error(e.getMessage());
                }
            }
        }
        return rs;
    }
    
    /**
     * 通过Excel文档获取值返回二维数组
     * 
     * @param pathFile
     *            文件路径
     * @return String[][] 二维数组
     */
    public static String[][] getArrFromFileXlsx(String pathFile, int sheetNumber)
    {
        // 读取字段内容
        /*POIFSFileSystem fs;*/
        XSSFWorkbook wb;
        XSSFSheet sheet;
        XSSFRow row;
        String[][] rs = null;
        InputStream is = null;
        Map<Integer, String> map = new HashMap<Integer, String>();
        String str = "";
        try
        {
            is = new FileInputStream(pathFile);
            /*fs = new POIFSFileSystem(is);*/
            wb = new XSSFWorkbook(is);
            sheet = wb.getSheetAt(sheetNumber);
            int rowNum = sheet.getLastRowNum();
            row = sheet.getRow(0);
            int colNum = row.getPhysicalNumberOfCells();
            // 空数据
            if (rowNum == 0)
            {
                return null;
            }
            
            for (int i = 1; i <= rowNum; i++)
            {
                int a = 0;
                row = sheet.getRow(i);
                while (a < colNum)
                {
                    str += String.valueOf(getCellValue(row.getCell(a)));
                    a++;
                }
                map.put(i, str);
                str = "";
            }
            for (int m = 1; m <= map.size(); m++)
            {
                if (StringUtils.isBlank(map.get(m)))
                {
                    rowNum--;
                }
            }
            rs = new String[rowNum][];
            
            for (int i = 1; i <= rowNum; i++)
            {
                row = sheet.getRow(i);
                rs[i - 1] = new String[colNum];
                
                for (int j = 0; j < colNum; j++)
                {
                    if (!"null".equals(String.valueOf(getCellValue(row.getCell(j))))
                        && !"".equals(String.valueOf(getCellValue(row.getCell(j)))))
                    {
                        rs[i - 1][j] = String.valueOf(getCellValue(row.getCell(j))).trim();
                    }
                    else
                    {
                        rs[i - 1][j] = "";
                    }
                }
            }
        }
        
        catch (FileNotFoundException e)
        {
        	LOGGER.error(e.getMessage());
            return null;
        }
        catch (IOException e)
        {
        	LOGGER.error(e.getMessage());
            return null;
        }
        catch (Exception e)
        {
        	LOGGER.error(e.getMessage());
            return null;
        }
        finally
        {
            if (is != null)
            {
                try
                {
                    is.close();
                }
                catch (IOException e)
                {
                	LOGGER.error(e.getMessage());
                }
            }
        }
        return rs;
    }
    
    /**
     * 读取cell的内容
     * @param cell
     * @return [参数说明]
     * @return String [返回类型说明]
     * @exception throws [违例类型] [违例说明]
     * @see [类、类#方法、类#成员]
     */
    public static String getCellValue(Cell cell)
    {
        String value = null;
        try
        {
            if (cell == null)
            {
                return value;
            }
            else
            {
                switch (cell.getCellType())
                {
                    case HSSFCell.CELL_TYPE_STRING:
                        value = cell.getStringCellValue();
                        break;
                    case HSSFCell.CELL_TYPE_NUMERIC:
                        if (HSSFDateUtil.isCellDateFormatted(cell))
                        {
                            Date date = cell.getDateCellValue();
                            if (date != null)
                            {
                                value = new SimpleDateFormat("yyyy/MM/dd").format(date);
                            }
                            else
                            {
                                value = null;
                            }
                        }
                        else
                        {
                            value = new DecimalFormat("0").format(cell.getNumericCellValue());
                        }
                        break;
                    case HSSFCell.CELL_TYPE_FORMULA:
                        // 导入时如果为公式生成的数据则无值
                        if (!cell.getStringCellValue().equals(""))
                        {
                            value = cell.getStringCellValue();
                        }
                        else
                        {
                            value = cell.getNumericCellValue() + "";
                        }
                        break;
                    case HSSFCell.CELL_TYPE_BOOLEAN:
                        value = (cell.getBooleanCellValue() ? "Y" : "N");
                        break;
                    default:
                        break;
                }
            }
        }
        catch (Exception e)
        {
            LOGGER.error(e.getMessage(), e);
        }
        return value;
    }
    
    public XSSFWorkbook exportExcelXlsx(String title, String[] headers, String[] Col, Collection<T> dataset,
        String pattern)
    {
        if (pattern == null || pattern.equals(""))
            pattern = "yyy-MM-dd";
        // 声明一个工作薄
        XSSFWorkbook workbook = new XSSFWorkbook();
        // 生成一个表格
        XSSFSheet sheet = workbook.createSheet(title);
        // 设置表格默认列宽度为15个字节
        sheet.setDefaultColumnWidth(15);
        // 生成一个样式
        XSSFCellStyle style = workbook.createCellStyle();
        // 设置这些样式
        style.setFillForegroundColor(HSSFColor.SKY_BLUE.index);
        style.setFillPattern(CellStyle.SOLID_FOREGROUND);
        style.setBorderBottom(CellStyle.BORDER_THIN);
        style.setBorderLeft(CellStyle.BORDER_THIN);
        style.setBorderRight(CellStyle.BORDER_THIN);
        style.setBorderTop(CellStyle.BORDER_THIN);
        style.setAlignment(CellStyle.ALIGN_CENTER);
        // 生成一个字体
        XSSFFont font = workbook.createFont();
        font.setColor(HSSFColor.BLACK.index);
        font.setFontHeightInPoints((short)12);
        font.setBoldweight(XSSFFont.BOLDWEIGHT_BOLD);
        // 把字体应用到当前的样式
        style.setFont(font);
        // 生成并设置另一个样式
        XSSFCellStyle style2 = workbook.createCellStyle();
        style2.setFillForegroundColor(HSSFColor.WHITE.index);
        style2.setFillPattern(CellStyle.SOLID_FOREGROUND);
        style2.setBorderBottom(CellStyle.BORDER_THIN);
        style2.setBorderLeft(CellStyle.BORDER_THIN);
        style2.setBorderRight(CellStyle.BORDER_THIN);
        style2.setBorderTop(CellStyle.BORDER_THIN);
        style2.setAlignment(CellStyle.ALIGN_CENTER);
        style2.setVerticalAlignment(CellStyle.VERTICAL_CENTER);
        // 生成另一个字体
        XSSFFont font2 = workbook.createFont();
        font2.setBoldweight(XSSFFont.BOLDWEIGHT_NORMAL);
        // 把字体应用到当前的样式
        style2.setFont(font2);
        // 产生表格标题行
        XSSFRow row = sheet.createRow(0);
        int Cell = 0;
        for (short i = 0; i < headers.length; i++)
        {
            XSSFCell cell = row.createCell(Cell);
            cell.setCellStyle(style);
            XSSFRichTextString text = new XSSFRichTextString(headers[i]);
            cell.setCellValue(text);
            Cell++;
        }
        // 遍历集合数据，产生数据行
        Iterator<T> it = dataset.iterator();
        int index = 0;
        while (it.hasNext())
        {
            index++;
            row = sheet.createRow(index);
            T t = (T)it.next();
            String[] fields = Col;
            Cell = 0;
            for (short i = 0; i < fields.length; i++)
            {
                String fieldName = fields[i];
                XSSFCell cell = row.createCell(Cell);
                cell.setCellStyle(style2);
                try
                {
                    Object value = "";
                    Class tCls = null;
                    Map map = null;
                    if (t instanceof Map)
                    {
                        map = (Map)t;
                        value = map.get(fieldName);
                    }
                    else
                    {
                        String getMethodName = "get" + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);
                        tCls = t.getClass();
                        Method getMethod = tCls.getMethod(getMethodName, new Class[] {});
                        value = getMethod.invoke(t, new Object[] {});
                    }
                    if (value == null)
                        value = "";
                    // 判断值的类型后进行强制类型转换
                    String textValue = null;
                    if (value instanceof Date)
                    {
                        Date date = (Date)value;
                        SimpleDateFormat sdf = new SimpleDateFormat(pattern);
                        textValue = sdf.format(date);
                    }
                    else if (value instanceof byte[])
                    {
                        // 有图片时，设置行高为60px;
                        row.setHeightInPoints(60);
                        // 设置图片所在列宽度为80px,注意这里单位的一个换算
                        sheet.setColumnWidth(Cell, (short)(35.7 * 80));
                        // sheet.autoSizeColumn(i);
                        byte[] bsValue = (byte[])value;
                        /*                        XSSFClientAnchor anchor = new XSSFClientAnchor(0, 0,
                                1023, 255, (short) 6, index, (short) 6, index);*/
                        //anchor.setAnchorType(2);
                    }
                    else
                    {
                        // 其它数据类型都当作字符串简单处理
                        textValue = value.toString();
                    }
                    // 如果不是图片数据，就利用正则表达式判断textValue是否全部由数字组成
                    if (textValue != null)
                    {
                        Pattern p = Pattern.compile("^//d+(//.//d+)?$");
                        Matcher matcher = p.matcher(textValue);
                        if (matcher.matches())
                        {
                            // 是数字当作double处理
                            cell.setCellValue(Double.parseDouble(textValue));
                        }
                        else
                        {
                            XSSFRichTextString richString = new XSSFRichTextString(textValue);
                            XSSFFont font3 = workbook.createFont();
                            font3.setColor(HSSFColor.BLACK.index);
                            richString.applyFont(font3);
                            cell.setCellValue(richString);
                        }
                    }
                    Cell++;
                }
                catch (Exception e)
                {
                    LOGGER.error(e.getMessage());
                }
            }
        }
        return workbook;
    }
    
    public void exportExcelXlsxThreeSheets(XSSFWorkbook workbook, String[] SheetNames, String[] totalScore,String[] headers, String[] Col,
        Collection<T> dataset1, Collection<T> dataset2, String pattern)
    {
        if (pattern == null || pattern.equals(""))
            pattern = "yyy-MM-dd";
        workbookCreateSheet(workbook, SheetNames[0], totalScore,headers, Col, dataset1, pattern);
        workbookCreateSheet(workbook, SheetNames[1], totalScore,headers, Col, dataset2, pattern);
    }
    
    public void workbookCreateSheet(XSSFWorkbook workbook, String sheetName,String[] totalScore, String[] headers, String[] Col,
        Collection<T> dataset, String pattern)
    {
        // 生成一个表格
        XSSFSheet sheet = workbook.createSheet(sheetName);
        // 设置表格默认列宽度为15个字节
        sheet.setDefaultColumnWidth(15);
        // 生成一个样式
        XSSFCellStyle style = workbook.createCellStyle();
        // 设置这些样式
        style.setFillForegroundColor(HSSFColor.SKY_BLUE.index);
        style.setFillPattern(CellStyle.SOLID_FOREGROUND);
        style.setBorderBottom(CellStyle.BORDER_THIN);
        style.setBorderLeft(CellStyle.BORDER_THIN);
        style.setBorderRight(CellStyle.BORDER_THIN);
        style.setBorderTop(CellStyle.BORDER_THIN);
        style.setAlignment(CellStyle.ALIGN_CENTER);
        // 生成一个字体
        XSSFFont font = workbook.createFont();
        font.setColor(HSSFColor.BLACK.index);
        font.setFontHeightInPoints((short)12);
        font.setBoldweight(XSSFFont.BOLDWEIGHT_BOLD);
        // 把字体应用到当前的样式
        style.setFont(font);
        // 生成并设置另一个样式
        XSSFCellStyle style2 = workbook.createCellStyle();
        style2.setFillForegroundColor(HSSFColor.WHITE.index);
        style2.setFillPattern(CellStyle.SOLID_FOREGROUND);
        style2.setBorderBottom(CellStyle.BORDER_THIN);
        style2.setBorderLeft(CellStyle.BORDER_THIN);
        style2.setBorderRight(CellStyle.BORDER_THIN);
        style2.setBorderTop(CellStyle.BORDER_THIN);
        style2.setAlignment(CellStyle.ALIGN_CENTER);
        style2.setVerticalAlignment(CellStyle.VERTICAL_CENTER);
        // 生成另一个字体
        XSSFFont font2 = workbook.createFont();
        font2.setBoldweight(XSSFFont.BOLDWEIGHT_NORMAL);
        // 把字体应用到当前的样式
        style2.setFont(font2);
        
        // 总分行
        XSSFRow scoreRow = sheet.createRow(0);
        int Cell = 0;
        for (short i = 0; i < totalScore.length; i++)
        {
            XSSFCell cell = scoreRow.createCell(Cell);
            cell.setCellStyle(style);
            XSSFRichTextString text = new XSSFRichTextString(totalScore[i]);
            cell.setCellValue(text);
            Cell++;
        }
        
        // 产生表格标题行
        XSSFRow row = sheet.createRow(1);
        int titleCell = 0;
        for (short i = 0; i < headers.length; i++)
        {
            XSSFCell cell = row.createCell(titleCell);
            cell.setCellStyle(style);
            XSSFRichTextString text = new XSSFRichTextString(headers[i]);
            cell.setCellValue(text);
            titleCell++;
        }
        // 遍历集合数据，产生数据行
        Iterator<T> it = dataset.iterator();
        int index = 1;
        while (it.hasNext())
        {
            index++;
            row = sheet.createRow(index);
            T t = (T)it.next();
            String[] fields = Col;
            Cell = 0;
            for (short i = 0; i < fields.length; i++)
            {
                String fieldName = fields[i];
                XSSFCell cell = row.createCell(Cell);
                cell.setCellStyle(style2);
                try
                {
                    Object value = "";
                    Class tCls = null;
                    Map map = null;
                    if (t instanceof Map)
                    {
                        map = (Map)t;
                        value = map.get(fieldName);
                    }
                    else
                    {
                        String getMethodName = "get" + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);
                        tCls = t.getClass();
                        Method getMethod = tCls.getMethod(getMethodName, new Class[] {});
                        value = getMethod.invoke(t, new Object[] {});
                    }
                    if (value == null)
                        value = "";
                    // 判断值的类型后进行强制类型转换
                    String textValue = null;
                    if (value instanceof Date)
                    {
                        Date date = (Date)value;
                        SimpleDateFormat sdf = new SimpleDateFormat(pattern);
                        textValue = sdf.format(date);
                    }
                    else if (value instanceof byte[])
                    {
                        // 有图片时，设置行高为60px;
                        row.setHeightInPoints(60);
                        // 设置图片所在列宽度为80px,注意这里单位的一个换算
                        sheet.setColumnWidth(Cell, (short)(35.7 * 80));
                        // sheet.autoSizeColumn(i);
                        byte[] bsValue = (byte[])value;
                        /*                        XSSFClientAnchor anchor = new XSSFClientAnchor(0, 0,
                                1023, 255, (short) 6, index, (short) 6, index);*/
                        //anchor.setAnchorType(2);
                    }
                    else
                    {
                        // 其它数据类型都当作字符串简单处理
                        textValue = value.toString();
                    }
                    // 如果不是图片数据，就利用正则表达式判断textValue是否全部由数字组成
                    if (textValue != null)
                    {
                        Pattern p = Pattern.compile("^//d+(//.//d+)?$");
                        Matcher matcher = p.matcher(textValue);
                        if (matcher.matches())
                        {
                            // 是数字当作double处理
                            cell.setCellValue(Double.parseDouble(textValue));
                        }
                        else
                        {
                            XSSFRichTextString richString = new XSSFRichTextString(textValue);
                            XSSFFont font3 = workbook.createFont();
                            font3.setColor(HSSFColor.BLACK.index);
                            richString.applyFont(font3);
                            cell.setCellValue(richString);
                        }
                    }
                    Cell++;
                }
                catch (Exception e)
                {
                	LOGGER.error(e.getMessage());
                }
            }
        }
    }
    
}

