http://www.cnblogs.com/hooray/archive/2012/09/05/2672133.html
https://www.cnblogs.com/sz-zzm/p/5218696.html
	
java 项目日志管理设计方案
https://blog.csdn.net/jlh912008548/article/details/72782241

springboot整合Quartz实现动态配置定时任务,不用了
https://blog.csdn.net/liuchuanhong1/article/details/60873295

Spring Boot配置定时任务（实例）
https://blog.csdn.net/m0_37885618/article/details/77196691

联想功能添加div

自动化测试工具
https://blog.csdn.net/jlh912008548/article/details/72782241

无注解的官方样例
https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples

小马哥的lesson
https://github.com/mercyblitz/segmentfault-lessons


2，git操作
Git日常三板斧- 分支操作
查看本地分支 git branch
查看所有分支(本地以及远程) git branch –a 
创建并切换分支：git checkout –b xxx origin/xxx
切换分支：git checkout xxx

git branch xx创建本地分支
git branch -d 删除分支

git checkout . #本地所有修改的。没有的提交的，都返回到原来的状态
git stash #把所有没有提交的修改暂存到stash里面。可用git stash pop回复。
git reset --hard HASH #返回到某个节点，不保留修改。
git reset --soft HASH #返回到某个节点。保留修改

Git日常三板斧-代码提交
添加至index：git add file，也可以用git add –u，只提交加入版本追踪的文件
提交至本地仓库：git commit –m ‘功能描述’，也可以使用git commit –amend，追加至上一次提交，前提是上一次提交没有push
更新代码：git pull origin branchName 
上一步如有冲突，解决完冲突后从第一步执行一遍，直至没有冲突
推送至远程仓库： git push origin branchName 

git 开发流程
暂存代码：git merge   (注:建议附加选项--squash)
上一步如果有冲突，解决完冲突提交代码

Git使用-代码丢弃、回滚
回滚到workspack:git reset xxx
把改动丢弃:git checkout -- file

Git使用-其他常用命令
git show
git log
git diff

Git 开发流程
master
feature
release
任务开发在feature分支上，开发完毕，从master分支创建release分支，将feature分支合并至release分支，然后发布release分支，完成后，将release分支合并至master分支，同时删除feature分支



ApplicationContextUtil.java
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;

@Component
public class ApplicationContextUtil implements ApplicationContextAware 
{
    private static ApplicationContext context;

    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        context = applicationContext;
    }
    
    public static ApplicationContext getApplicationContext() {
        return context;
    }
}

ConfLoadUtil.java
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.io.ClassPathResource;

import com.fasterxml.jackson.core.type.TypeReference;
import com.huawei.searchevaluate.models.PriorityNumConfModel;

/**
 * 配置文件加载工具类
 * Created by xWX343760 on 2018/8/25.
 */
public class ConfLoadUtil
{
    private final Logger LOG = LoggerFactory.getLogger(ConfLoadUtil.class);
    
    private final static String PRIORITY_CONF = "static/resources/jsonfiles/record_priority_num_conf.json";
    private final static String WEIGHT_CONF = "static/resources/jsonfiles/record_operation_weight_conf.json";
    
    private List<PriorityNumConfModel> priorityNumConf = new ArrayList<>();
    private Map<String, Integer> operationWeightMap = new HashMap<>();
    private Map<String, String> propertiesConfMap = new HashMap<>();

    private final static ConfLoadUtil confLoadUtil = new ConfLoadUtil();

    private ConfLoadUtil()
    {
        loadJsonConf();
        loadPropertiesConf();
    }

    public void loadJsonConf()
    {
        try
        {
            InputStream inputStream = null;
            ClassPathResource pathResource = new ClassPathResource(PRIORITY_CONF);
            inputStream = pathResource.getInputStream();
            priorityNumConf = JsonUtil.fromJson(inputStream, new TypeReference<List<PriorityNumConfModel>>()
            {
            });
        }
        catch (IllegalArgumentException e)
        {
            LOG.info("parse priority conf file failed since exception:", e);
        }
        catch (IOException e)
        {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        try
        {
            InputStream inputStream = null;
            ClassPathResource pathResource = new ClassPathResource(WEIGHT_CONF);
            inputStream = pathResource.getInputStream();
            operationWeightMap = JsonUtil.fromJson(inputStream, new TypeReference<Map<String, Integer>>()
            {
            });
        }
        catch (IllegalArgumentException e)
        {
            LOG.info("parse weight conf file failed since exception:", e);
        }
        catch (IOException e)
        {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public void loadPropertiesConf()
    {
        this.propertiesConfMap = loadProperties("conf.properties");
    }

    private Map<String, String> loadProperties(String filename)
    {
        Map<String, String> map = new HashMap<String, String>();
        Properties properties = new Properties();
        InputStream is = ConfLoadUtil.class.getClassLoader().getResourceAsStream(filename);
        try
        {
            properties.load(is);
            for (Map.Entry entry : properties.entrySet())
            {
                String key = (String) entry.getKey();
                String value = (String) entry.getValue();
                value = new String(value.getBytes("ISO-8859-1"), "utf-8");
                map.put(key, value);
            }
        }
        catch (Exception e)
        {
            LOG.error("can't load properties: ", e);
        }
        finally
        {
            try
            {
                if (is != null)
                {
                    is.close();
                }
            }
            catch (IOException e)
            {
                LOG.error("close is exception: ", e);
            }
        }
        return map;
    }

    public static ConfLoadUtil getInstance()
    {
        return confLoadUtil;
    }

    public void reloadConf()
    {
        loadJsonConf();
    }

    public List<PriorityNumConfModel> getPriorityNumConf()
    {
        return this.priorityNumConf;
    }

    public Map<String, Integer> getOperationWeightMap()
    {
        return this.operationWeightMap;
    }

    public String getPropertyValueByKey(String key)
    {
        return propertiesConfMap.getOrDefault(key, "");
    }
}

DownloadUtil.java
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.io.ClassPathResource;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.multipart.support.StandardMultipartHttpServletRequest;


/**
 * 下载上传文件工具类
 * @author  lWX458995
 * @version  [版本号, 2018年8月16日]
 * @see  [相关类/方法]
 * @since  [产品/模块版本]
 */
public class DownloadUtil
{
    private static final Logger LOGGER = LoggerFactory.getLogger(DownloadUtil.class);
    
    /**
     * 下载静态资源路径下的模板
     * @param request
     * @param response
     * @param filePath 相对于src/main/resources的路径
     * @param fileName [参数说明]
     * 
     * @return void [返回类型说明]
     * @exception throws [违例类型] [违例说明]
     * @see [类、类#方法、类#成员]
     */
    public static void downloadFileStaticResource(HttpServletRequest request, HttpServletResponse response, String filePath, String fileName)
    {
        BufferedInputStream in = null;
        BufferedOutputStream out = null;
        InputStream inputStream = null;
        try
        {
            ClassPathResource classPathResource = new ClassPathResource(filePath + fileName);
            inputStream = classPathResource.getInputStream();
            response.setContentType("application/x-excel");
            response.setCharacterEncoding("UTF-8");
            response.setHeader("Content-Disposition",
                "attachment;filename=" + new String(fileName.getBytes("gbk"), "iso-8859-1"));
            //response.setHeader("Content-Length", String.valueOf(f.length()));
            in = new BufferedInputStream(inputStream);
            out = new BufferedOutputStream(response.getOutputStream());
            byte[] data = new byte[1024];
            int len = 0;
            while (-1 != (len = in.read(data, 0, data.length)))
            {
                out.write(data, 0, len);
            }
        }
        catch (FileNotFoundException e)
        {
        	LOGGER.error(e.getMessage());
        }
        catch (IOException e)
        {
        	LOGGER.error(e.getMessage());
        }
        finally
        {
        	if(null != inputStream){
        		try {
					inputStream.close();
				} catch (IOException e) {
					LOGGER.error(e.getMessage());
				}
        	}
            IOUtils.closeQuietly(in);
            IOUtils.closeQuietly(out);
        }
    }
    
    /**
     * 下载磁盘路径下的模板
     * @param request
     * @param response
     * @param filePath 绝对路径
     * @param fileName [参数说明]
     * 
     * @return void [返回类型说明]
     * @exception throws [违例类型] [违例说明]
     * @see [类、类#方法、类#成员]
     */
    public static void downloadFile(HttpServletRequest request, HttpServletResponse response,String filePath, String fileName)
    {
        BufferedInputStream in = null;
        BufferedOutputStream out = null;
        try
        {
            File f = new File(filePath+fileName);
            response.setContentType("application/x-excel");
            response.setCharacterEncoding("UTF-8");
            response.setHeader("Content-Disposition",
                "attachment;filename=" + new String(fileName.getBytes("gbk"), "iso-8859-1"));
            response.setHeader("Content-Length", String.valueOf(f.length()));
            in = new BufferedInputStream(new FileInputStream(f));
            out = new BufferedOutputStream(response.getOutputStream());
            byte[] data = new byte[1024];
            int len = 0;
            while (-1 != (len = in.read(data, 0, data.length)))
            {
                out.write(data, 0, len);
            }
        }
        catch (FileNotFoundException e)
        {
            LOGGER.error(e.getMessage());
        }
        catch (IOException e)
        {
            LOGGER.error(e.getMessage());
        }
        finally
        {
            IOUtils.closeQuietly(in);
            IOUtils.closeQuietly(out);
        }
    }
    
    /**
     * 上传文件到指定路径filePath 并命名为fileName,返回新生成的文件路径
     * @param request
     * @param filePath
     * @param fileName [参数说明]
     * 
     * @return void [返回类型说明]
     * @exception throws [违例类型] [违例说明]
     * @see [类、类#方法、类#成员]
     */
    public static String uploadFile(HttpServletRequest request, String filePath, String fileName)
    {
        // TODO Auto-generated method stub
        BufferedInputStream in = null;
        BufferedOutputStream out = null;
        try {
            StandardMultipartHttpServletRequest req = (StandardMultipartHttpServletRequest) request;
            Iterator<String> iterator = req.getFileNames();
            while (iterator.hasNext()) {
                MultipartFile file = req.getFile(iterator.next());          
                in = new BufferedInputStream(file.getInputStream());
                out = new BufferedOutputStream(new FileOutputStream(filePath+fileName));
                byte buffer[] = new byte[1024];
                int len = 0;
                while (-1 != (len = in.read(buffer, 0, buffer.length)))
                {
                    out.write(buffer, 0, len);
                }
            }
        }
        catch (IllegalStateException e)
        {
            LOGGER.error(e.getMessage());
        }
        catch(Exception e) {
            LOGGER.error(e.getMessage());
        }finally {
            IOUtils.closeQuietly(in);
            IOUtils.closeQuietly(out);
        }
		return filePath+fileName;
        
    }
}

ExcelDataUtils.java
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang3.StringUtils;
import org.apache.poi.hssf.usermodel.HSSFCell;
import org.apache.poi.hssf.usermodel.HSSFDateUtil;
import org.apache.poi.hssf.util.HSSFColor;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.xssf.usermodel.XSSFCell;
import org.apache.poi.xssf.usermodel.XSSFCellStyle;
import org.apache.poi.xssf.usermodel.XSSFFont;
import org.apache.poi.xssf.usermodel.XSSFRichTextString;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * 处理excel文档
 * @author  lWX458995
 * @version  [版本号, 2018年4月23日]
 * @see  [相关类/方法]
 * @since  [产品/模块版本]
 */
public class ExcelDataUtils<T>
{
    private static final Logger LOGGER = LoggerFactory.getLogger(ExcelDataUtils.class);
    
    /**
     * 通过Excel文档获取值返回二维数组
     * 
     * @param pathFile
     *            文件路径
     * @return String[][] 二维数组
     */
    public static String[][] getArrFromFileXls(String pathFile, int sheetNumber)
    {
        // 读取字段内容
        /*POIFSFileSystem fs;*/
        XSSFWorkbook wb;
        XSSFSheet sheet;
        XSSFRow row;
        String[][] rs = null;
        InputStream is = null;
        Map<Integer, String> map = new HashMap<Integer, String>();
        String str = "";
        try
        {
            is = new FileInputStream(pathFile);
            /*fs = new POIFSFileSystem(is);*/
            wb = new XSSFWorkbook(is);
            sheet = wb.getSheetAt(sheetNumber);
            int rowNum = sheet.getLastRowNum();
            row = sheet.getRow(0);
            int colNum = row.getPhysicalNumberOfCells();
            // 空数据
            if (rowNum == 0)
            {
                return null;
            }
            
            for (int i = 1; i <= rowNum; i++)
            {
                int a = 0;
                row = sheet.getRow(i);
                while (a < colNum)
                {
                    str += String.valueOf(getCellValue(row.getCell(a)));
                    a++;
                }
                map.put(i, str);
                str = "";
            }
            for (int m = 1; m <= map.size(); m++)
            {
                if (StringUtils.isBlank(map.get(m)))
                {
                    rowNum--;
                }
            }
            rs = new String[rowNum][];
            
            for (int i = 1; i <= rowNum; i++)
            {
                row = sheet.getRow(i);
                rs[i - 1] = new String[colNum];
                
                for (int j = 0; j < colNum; j++)
                {
                    if (!"null".equals(String.valueOf(getCellValue(row.getCell(j))))
                        && !"".equals(String.valueOf(getCellValue(row.getCell(j)))))
                    {
                        rs[i - 1][j] = String.valueOf(getCellValue(row.getCell(j))).trim();
                    }
                    else
                    {
                        rs[i - 1][j] = "";
                    }
                }
            }
        }
        
        catch (FileNotFoundException e)
        {
        	LOGGER.error(e.getMessage());
            return null;
        }
        catch (IOException e)
        {
        	LOGGER.error(e.getMessage());
            return null;
        }
        catch (Exception e)
        {
        	LOGGER.error(e.getMessage());
            return null;
        }
        finally
        {
            if (is != null)
            {
                try
                {
                    is.close();
                }
                catch (IOException e)
                {
                	LOGGER.error(e.getMessage());
                }
            }
        }
        return rs;
    }
    
    /**
     * 通过Excel文档获取值返回二维数组
     * 
     * @param pathFile
     *            文件路径
     * @return String[][] 二维数组
     */
    public static String[][] getArrFromFileXlsx(String pathFile, int sheetNumber)
    {
        // 读取字段内容
        /*POIFSFileSystem fs;*/
        XSSFWorkbook wb;
        XSSFSheet sheet;
        XSSFRow row;
        String[][] rs = null;
        InputStream is = null;
        Map<Integer, String> map = new HashMap<Integer, String>();
        String str = "";
        try
        {
            is = new FileInputStream(pathFile);
            /*fs = new POIFSFileSystem(is);*/
            wb = new XSSFWorkbook(is);
            sheet = wb.getSheetAt(sheetNumber);
            int rowNum = sheet.getLastRowNum();
            row = sheet.getRow(0);
            int colNum = row.getPhysicalNumberOfCells();
            // 空数据
            if (rowNum == 0)
            {
                return null;
            }
            
            for (int i = 1; i <= rowNum; i++)
            {
                int a = 0;
                row = sheet.getRow(i);
                while (a < colNum)
                {
                    str += String.valueOf(getCellValue(row.getCell(a)));
                    a++;
                }
                map.put(i, str);
                str = "";
            }
            for (int m = 1; m <= map.size(); m++)
            {
                if (StringUtils.isBlank(map.get(m)))
                {
                    rowNum--;
                }
            }
            rs = new String[rowNum][];
            
            for (int i = 1; i <= rowNum; i++)
            {
                row = sheet.getRow(i);
                rs[i - 1] = new String[colNum];
                
                for (int j = 0; j < colNum; j++)
                {
                    if (!"null".equals(String.valueOf(getCellValue(row.getCell(j))))
                        && !"".equals(String.valueOf(getCellValue(row.getCell(j)))))
                    {
                        rs[i - 1][j] = String.valueOf(getCellValue(row.getCell(j))).trim();
                    }
                    else
                    {
                        rs[i - 1][j] = "";
                    }
                }
            }
        }
        
        catch (FileNotFoundException e)
        {
        	LOGGER.error(e.getMessage());
            return null;
        }
        catch (IOException e)
        {
        	LOGGER.error(e.getMessage());
            return null;
        }
        catch (Exception e)
        {
        	LOGGER.error(e.getMessage());
            return null;
        }
        finally
        {
            if (is != null)
            {
                try
                {
                    is.close();
                }
                catch (IOException e)
                {
                	LOGGER.error(e.getMessage());
                }
            }
        }
        return rs;
    }
    
    /**
     * 读取cell的内容
     * @param cell
     * @return [参数说明]
     * @return String [返回类型说明]
     * @exception throws [违例类型] [违例说明]
     * @see [类、类#方法、类#成员]
     */
    public static String getCellValue(Cell cell)
    {
        String value = null;
        try
        {
            if (cell == null)
            {
                return value;
            }
            else
            {
                switch (cell.getCellType())
                {
                    case HSSFCell.CELL_TYPE_STRING:
                        value = cell.getStringCellValue();
                        break;
                    case HSSFCell.CELL_TYPE_NUMERIC:
                        if (HSSFDateUtil.isCellDateFormatted(cell))
                        {
                            Date date = cell.getDateCellValue();
                            if (date != null)
                            {
                                value = new SimpleDateFormat("yyyy/MM/dd").format(date);
                            }
                            else
                            {
                                value = null;
                            }
                        }
                        else
                        {
                            value = new DecimalFormat("0").format(cell.getNumericCellValue());
                        }
                        break;
                    case HSSFCell.CELL_TYPE_FORMULA:
                        // 导入时如果为公式生成的数据则无值
                        if (!cell.getStringCellValue().equals(""))
                        {
                            value = cell.getStringCellValue();
                        }
                        else
                        {
                            value = cell.getNumericCellValue() + "";
                        }
                        break;
                    case HSSFCell.CELL_TYPE_BOOLEAN:
                        value = (cell.getBooleanCellValue() ? "Y" : "N");
                        break;
                    default:
                        break;
                }
            }
        }
        catch (Exception e)
        {
            LOGGER.error(e.getMessage(), e);
        }
        return value;
    }
    
    public XSSFWorkbook exportExcelXlsx(String title, String[] headers, String[] Col, Collection<T> dataset,
        String pattern)
    {
        if (pattern == null || pattern.equals(""))
            pattern = "yyy-MM-dd";
        // 声明一个工作薄
        XSSFWorkbook workbook = new XSSFWorkbook();
        // 生成一个表格
        XSSFSheet sheet = workbook.createSheet(title);
        // 设置表格默认列宽度为15个字节
        sheet.setDefaultColumnWidth(15);
        // 生成一个样式
        XSSFCellStyle style = workbook.createCellStyle();
        // 设置这些样式
        style.setFillForegroundColor(HSSFColor.SKY_BLUE.index);
        style.setFillPattern(CellStyle.SOLID_FOREGROUND);
        style.setBorderBottom(CellStyle.BORDER_THIN);
        style.setBorderLeft(CellStyle.BORDER_THIN);
        style.setBorderRight(CellStyle.BORDER_THIN);
        style.setBorderTop(CellStyle.BORDER_THIN);
        style.setAlignment(CellStyle.ALIGN_CENTER);
        // 生成一个字体
        XSSFFont font = workbook.createFont();
        font.setColor(HSSFColor.BLACK.index);
        font.setFontHeightInPoints((short)12);
        font.setBoldweight(XSSFFont.BOLDWEIGHT_BOLD);
        // 把字体应用到当前的样式
        style.setFont(font);
        // 生成并设置另一个样式
        XSSFCellStyle style2 = workbook.createCellStyle();
        style2.setFillForegroundColor(HSSFColor.WHITE.index);
        style2.setFillPattern(CellStyle.SOLID_FOREGROUND);
        style2.setBorderBottom(CellStyle.BORDER_THIN);
        style2.setBorderLeft(CellStyle.BORDER_THIN);
        style2.setBorderRight(CellStyle.BORDER_THIN);
        style2.setBorderTop(CellStyle.BORDER_THIN);
        style2.setAlignment(CellStyle.ALIGN_CENTER);
        style2.setVerticalAlignment(CellStyle.VERTICAL_CENTER);
        // 生成另一个字体
        XSSFFont font2 = workbook.createFont();
        font2.setBoldweight(XSSFFont.BOLDWEIGHT_NORMAL);
        // 把字体应用到当前的样式
        style2.setFont(font2);
        // 产生表格标题行
        XSSFRow row = sheet.createRow(0);
        int Cell = 0;
        for (short i = 0; i < headers.length; i++)
        {
            XSSFCell cell = row.createCell(Cell);
            cell.setCellStyle(style);
            XSSFRichTextString text = new XSSFRichTextString(headers[i]);
            cell.setCellValue(text);
            Cell++;
        }
        // 遍历集合数据，产生数据行
        Iterator<T> it = dataset.iterator();
        int index = 0;
        while (it.hasNext())
        {
            index++;
            row = sheet.createRow(index);
            T t = (T)it.next();
            String[] fields = Col;
            Cell = 0;
            for (short i = 0; i < fields.length; i++)
            {
                String fieldName = fields[i];
                XSSFCell cell = row.createCell(Cell);
                cell.setCellStyle(style2);
                try
                {
                    Object value = "";
                    Class tCls = null;
                    Map map = null;
                    if (t instanceof Map)
                    {
                        map = (Map)t;
                        value = map.get(fieldName);
                    }
                    else
                    {
                        String getMethodName = "get" + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);
                        tCls = t.getClass();
                        Method getMethod = tCls.getMethod(getMethodName, new Class[] {});
                        value = getMethod.invoke(t, new Object[] {});
                    }
                    if (value == null)
                        value = "";
                    // 判断值的类型后进行强制类型转换
                    String textValue = null;
                    if (value instanceof Date)
                    {
                        Date date = (Date)value;
                        SimpleDateFormat sdf = new SimpleDateFormat(pattern);
                        textValue = sdf.format(date);
                    }
                    else if (value instanceof byte[])
                    {
                        // 有图片时，设置行高为60px;
                        row.setHeightInPoints(60);
                        // 设置图片所在列宽度为80px,注意这里单位的一个换算
                        sheet.setColumnWidth(Cell, (short)(35.7 * 80));
                        // sheet.autoSizeColumn(i);
                        byte[] bsValue = (byte[])value;
                        /*                        XSSFClientAnchor anchor = new XSSFClientAnchor(0, 0,
                                1023, 255, (short) 6, index, (short) 6, index);*/
                        //anchor.setAnchorType(2);
                    }
                    else
                    {
                        // 其它数据类型都当作字符串简单处理
                        textValue = value.toString();
                    }
                    // 如果不是图片数据，就利用正则表达式判断textValue是否全部由数字组成
                    if (textValue != null)
                    {
                        Pattern p = Pattern.compile("^//d+(//.//d+)?$");
                        Matcher matcher = p.matcher(textValue);
                        if (matcher.matches())
                        {
                            // 是数字当作double处理
                            cell.setCellValue(Double.parseDouble(textValue));
                        }
                        else
                        {
                            XSSFRichTextString richString = new XSSFRichTextString(textValue);
                            XSSFFont font3 = workbook.createFont();
                            font3.setColor(HSSFColor.BLACK.index);
                            richString.applyFont(font3);
                            cell.setCellValue(richString);
                        }
                    }
                    Cell++;
                }
                catch (Exception e)
                {
                    LOGGER.error(e.getMessage());
                }
            }
        }
        return workbook;
    }
    
    public void exportExcelXlsxThreeSheets(XSSFWorkbook workbook, String[] SheetNames, String[] totalScore,String[] headers, String[] Col,
        Collection<T> dataset1, Collection<T> dataset2, String pattern)
    {
        if (pattern == null || pattern.equals(""))
            pattern = "yyy-MM-dd";
        workbookCreateSheet(workbook, SheetNames[0], totalScore,headers, Col, dataset1, pattern);
        workbookCreateSheet(workbook, SheetNames[1], totalScore,headers, Col, dataset2, pattern);
    }
    
    public void workbookCreateSheet(XSSFWorkbook workbook, String sheetName,String[] totalScore, String[] headers, String[] Col,
        Collection<T> dataset, String pattern)
    {
        // 生成一个表格
        XSSFSheet sheet = workbook.createSheet(sheetName);
        // 设置表格默认列宽度为15个字节
        sheet.setDefaultColumnWidth(15);
        // 生成一个样式
        XSSFCellStyle style = workbook.createCellStyle();
        // 设置这些样式
        style.setFillForegroundColor(HSSFColor.SKY_BLUE.index);
        style.setFillPattern(CellStyle.SOLID_FOREGROUND);
        style.setBorderBottom(CellStyle.BORDER_THIN);
        style.setBorderLeft(CellStyle.BORDER_THIN);
        style.setBorderRight(CellStyle.BORDER_THIN);
        style.setBorderTop(CellStyle.BORDER_THIN);
        style.setAlignment(CellStyle.ALIGN_CENTER);
        // 生成一个字体
        XSSFFont font = workbook.createFont();
        font.setColor(HSSFColor.BLACK.index);
        font.setFontHeightInPoints((short)12);
        font.setBoldweight(XSSFFont.BOLDWEIGHT_BOLD);
        // 把字体应用到当前的样式
        style.setFont(font);
        // 生成并设置另一个样式
        XSSFCellStyle style2 = workbook.createCellStyle();
        style2.setFillForegroundColor(HSSFColor.WHITE.index);
        style2.setFillPattern(CellStyle.SOLID_FOREGROUND);
        style2.setBorderBottom(CellStyle.BORDER_THIN);
        style2.setBorderLeft(CellStyle.BORDER_THIN);
        style2.setBorderRight(CellStyle.BORDER_THIN);
        style2.setBorderTop(CellStyle.BORDER_THIN);
        style2.setAlignment(CellStyle.ALIGN_CENTER);
        style2.setVerticalAlignment(CellStyle.VERTICAL_CENTER);
        // 生成另一个字体
        XSSFFont font2 = workbook.createFont();
        font2.setBoldweight(XSSFFont.BOLDWEIGHT_NORMAL);
        // 把字体应用到当前的样式
        style2.setFont(font2);
        
        // 总分行
        XSSFRow scoreRow = sheet.createRow(0);
        int Cell = 0;
        for (short i = 0; i < totalScore.length; i++)
        {
            XSSFCell cell = scoreRow.createCell(Cell);
            cell.setCellStyle(style);
            XSSFRichTextString text = new XSSFRichTextString(totalScore[i]);
            cell.setCellValue(text);
            Cell++;
        }
        
        // 产生表格标题行
        XSSFRow row = sheet.createRow(1);
        int titleCell = 0;
        for (short i = 0; i < headers.length; i++)
        {
            XSSFCell cell = row.createCell(titleCell);
            cell.setCellStyle(style);
            XSSFRichTextString text = new XSSFRichTextString(headers[i]);
            cell.setCellValue(text);
            titleCell++;
        }
        // 遍历集合数据，产生数据行
        Iterator<T> it = dataset.iterator();
        int index = 1;
        while (it.hasNext())
        {
            index++;
            row = sheet.createRow(index);
            T t = (T)it.next();
            String[] fields = Col;
            Cell = 0;
            for (short i = 0; i < fields.length; i++)
            {
                String fieldName = fields[i];
                XSSFCell cell = row.createCell(Cell);
                cell.setCellStyle(style2);
                try
                {
                    Object value = "";
                    Class tCls = null;
                    Map map = null;
                    if (t instanceof Map)
                    {
                        map = (Map)t;
                        value = map.get(fieldName);
                    }
                    else
                    {
                        String getMethodName = "get" + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);
                        tCls = t.getClass();
                        Method getMethod = tCls.getMethod(getMethodName, new Class[] {});
                        value = getMethod.invoke(t, new Object[] {});
                    }
                    if (value == null)
                        value = "";
                    // 判断值的类型后进行强制类型转换
                    String textValue = null;
                    if (value instanceof Date)
                    {
                        Date date = (Date)value;
                        SimpleDateFormat sdf = new SimpleDateFormat(pattern);
                        textValue = sdf.format(date);
                    }
                    else if (value instanceof byte[])
                    {
                        // 有图片时，设置行高为60px;
                        row.setHeightInPoints(60);
                        // 设置图片所在列宽度为80px,注意这里单位的一个换算
                        sheet.setColumnWidth(Cell, (short)(35.7 * 80));
                        // sheet.autoSizeColumn(i);
                        byte[] bsValue = (byte[])value;
                        /*                        XSSFClientAnchor anchor = new XSSFClientAnchor(0, 0,
                                1023, 255, (short) 6, index, (short) 6, index);*/
                        //anchor.setAnchorType(2);
                    }
                    else
                    {
                        // 其它数据类型都当作字符串简单处理
                        textValue = value.toString();
                    }
                    // 如果不是图片数据，就利用正则表达式判断textValue是否全部由数字组成
                    if (textValue != null)
                    {
                        Pattern p = Pattern.compile("^//d+(//.//d+)?$");
                        Matcher matcher = p.matcher(textValue);
                        if (matcher.matches())
                        {
                            // 是数字当作double处理
                            cell.setCellValue(Double.parseDouble(textValue));
                        }
                        else
                        {
                            XSSFRichTextString richString = new XSSFRichTextString(textValue);
                            XSSFFont font3 = workbook.createFont();
                            font3.setColor(HSSFColor.BLACK.index);
                            richString.applyFont(font3);
                            cell.setCellValue(richString);
                        }
                    }
                    Cell++;
                }
                catch (Exception e)
                {
                	LOGGER.error(e.getMessage());
                }
            }
        }
    }
    
}

