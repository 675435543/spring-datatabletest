CREATE TABLE `sys_user_log` (
  `log_id` varchar(32) NOT NULL COMMENT '日志表id，uuid',
  `user_id` varchar(32) DEFAULT NULL COMMENT '用户id,记录操作用户',
  `module_name` varchar(225) NOT NULL COMMENT '模块名称',
  `operate` varchar(225) NOT NULL COMMENT '操作名称',
  `time` datetime NOT NULL COMMENT '操作时间',
  `class_name` varchar(225) NOT NULL COMMENT '类名称',
  `method_name` varchar(225) NOT NULL COMMENT '方法名称',
  `params` longtext COMMENT '传入参数',
  `ip` varchar(225) NOT NULL COMMENT '操作ip',
  PRIMARY KEY (`log_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

(2)工具类
AppExpertareaUtil.java
AsyncUtil.java
CfgHistoryProcessUtil.java
Constants.java
ConvertUtil.java
DownloadUtil.java
ExcelUtil.java
FileUtils.java
GalaxyUtil.java
LIST.TXT
ListUtils.java
MailUtil.java
MongodbUtil.java
MyMultipartResolver.java
NumConstants.java
PathUtil.java
PoiUtil.java
read.bat
RowValueClassType.java
ShortMsgUtil.java
SolrUpdateUtil.java
SourceUnionInitUtil.java
StatInfoProcessUtil.java
SynonymsUtil.java
SysConfig.java
TimeUtils.java
UniomLabelInitUtil.java
UserPermissionUtil.java
UserSearchStatProcessUtil.java
Util.java
ValidatorUtil.java

（1）几个修饰符
https://zhidao.baidu.com/question/89449594.html?fr=iks&word=%CD%BC%BD%E2public+protected+private&ie=gbk
在说明这四个关键字之前，我想就class之间的关系做一个简单的定义，对于继承自己的class，base class可以认为他们都是自己的子女，而对于和自己一个目录下的classes，认为都是自己的朋友。
1、public：public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用
2、private：private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用，私有财产神圣不可侵犯嘛，即便是子女，朋友，都不可以使用。
3、protected：protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private。

package com.java6666.lx;

public class Test
{
    private int a;
    protected int b;
    public int c;
    int d;
    
    public Test()
    {
        
    }

    public Test(int a, int b, int c, int d)
    {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
    }

    public static void main(String[] args){
    Test demo=new Test(0, 1, 2, 3);
    int test1=demo.a;
    int test2=demo.b;
    int test3=demo.c;
    int test4=demo.d;
    System.out.println("test1"+test1);
    System.out.println("test2"+test2);
    System.out.println("test3"+test3);
    System.out.println("test4"+test4);
    }
}

package com.java6666.lx;

public class TestPengYou
{
/*    
 *  private int a;
    protected int b;
    public int c;
    int d;
    */
    public static void main(String[] args){
    Test demo=new Test(0, 1, 2, 3);
    int test1=demo.a;
    int test2=demo.b;
    int test3=demo.c;
    int test4=demo.d;
    System.out.println("test1"+test1);
    System.out.println("test2"+test2);
    System.out.println("test3"+test3);
    System.out.println("test4"+test4);
    }
}

package com.java6666.lx2;

import com.java6666.lx.Test;

public class TestMoShengren
{
    /*    
     *  private int a;
        protected int b;
        public int c;
        int d;
        */
    public static void main(String[] args){
    Test demo=new Test(0, 1, 2, 3);
    int test1=demo.a;
    int test2=demo.b;
    int test3=demo.c;
    int test4=demo.d;
    System.out.println("test1"+test1);
    System.out.println("test2"+test2);
    System.out.println("test3"+test3);
    System.out.println("test4"+test4);
    }
}
package com.java6666.lx2;

import com.java6666.lx.Test;

public class TestZinv extends Test
{
    

    /*    
     *  private int a;
        protected int b;
        public int c;
        int d;
        */
    public TestZinv()
    {
        super();
        // TODO Auto-generated constructor stub
    }

    public TestZinv(int a, int b, int c, int d)
    {
        super(a, b, c, d);
    }
    public static void main(String[] args){
    TestZinv demo=new TestZinv(0, 1, 2, 3);
    int test1=demo.a;
    int test2=demo.b;
    int test3=demo.c;
    int test4=demo.d;
    System.out.println("test1"+test1);
    System.out.println("test2"+test2);
    System.out.println("test3"+test3);
    System.out.println("test4"+test4);
    }


    
}
package com.java6666.lx;

import com.java6666.lx.Test;

public class TestZinvAndPengyou extends Test
{
    

    /*    
     *  private int a;
        protected int b;
        public int c;
        int d;
        */
    public TestZinvAndPengyou()
    {
        super();
        // TODO Auto-generated constructor stub
    }

    public TestZinvAndPengyou(int a, int b, int c, int d)
    {
        super(a, b, c, d);
    }
    public static void main(String[] args){
    TestZinvAndPengyou demo=new TestZinvAndPengyou(0, 1, 2, 3);
    int test1=demo.a;
    int test2=demo.b;
    int test3=demo.c;
    int test4=demo.d;
    System.out.println("test1"+test1);
    System.out.println("test2"+test2);
    System.out.println("test3"+test3);
    System.out.println("test4"+test4);
    }


    
}
    /*    
     *  private int a; 
        protected int b; 子女和朋友
        public int c;
        int d;  朋友
        */
2）定时任务周期执行
public class TimerTest
{
    /**
     * 周期执行
     */
    private static final ScheduledExecutorService POOL = Executors.newScheduledThreadPool(1);
    
    
    static
    {

        long initialDelay = 0;
        long dayMilliseconds = 24 * 60 * 60 * 1000;
        try
        {
            String startTimeDefault = "10:41:00";
            String timeSpacingDefault = "1";
            //timeSpacingDefault天对应的毫秒数
            dayMilliseconds = Integer.parseInt(timeSpacingDefault)* 24 * 60 * 60 * 1000;
            System.out.println("dayMilliseconds:"+dayMilliseconds);
            final SimpleDateFormat dateFormatter = new SimpleDateFormat("yyyy-MM-dd "+startTimeDefault);
            System.out.println("日期:"+dateFormatter.format(new Date()));
            Date startTime = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(dateFormatter.format(new Date()));
            long time1 = startTime.getTime();
            
            System.out.println("time1:"+time1);
            
            if(System.currentTimeMillis() > startTime.getTime())
            {
                System.out.println("System.currentTimeMillis() > startTime.getTime()");
                startTime = new Date(startTime.getTime()+dayMilliseconds);
                initialDelay = startTime.getTime()-System.currentTimeMillis();
            }
            else
            {
                initialDelay = startTime.getTime()-System.currentTimeMillis();
            }
            long time2 = startTime.getTime();
            System.out.println("time2:"+time2);
            System.out.println("time2-time1:"+(time2-time1));
            System.out.println("System.currentTimeMillis:"+System.currentTimeMillis());
            
            System.out.println("initialDelay:"+initialDelay);
            System.out.println("initialDelayhour:"+initialDelay/1000/60/60);
        }
        catch (ParseException e)
        {
            System.out.println("定时任务在日期转换时出现错误!");
            e.printStackTrace();
        }
        dayMilliseconds = 1 * 1000;
        POOL.scheduleAtFixedRate(new Runnable()
        {
            @Override
            public void run()
            {
                System.out.println("我跑了一次");
            }
        }, initialDelay, dayMilliseconds, TimeUnit.MILLISECONDS);
    }
    public static void main(String[] args)
    {
/*        SimpleDateFormat dateFormatter = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");  
        Date startDate;
        try
        {
            startDate = dateFormatter.parse("2018/09/03 10:47:00");
            Timer timer = new Timer();
            timer.scheduleAtFixedRate(new TimerTask(){
            @Override
            public void run()  
            {  
                System.out.println("execute task!" + this.scheduledExecutionTime());  
            }  
            },startDate,1*60*1000);  
        }
        catch (ParseException e)
        {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }  */


    }
}

（1）定时任务实际例子
    static
    {
        long initialDelay = 0;
        long period = 24 * 60 * 60 * 1000;
        try
        {
            String startTimeDefault = null;
            String timeSpacingDefault = null;
            startTimeDefault = SysConfig.getIndexConfig("startTimeDefaultParam");
            timeSpacingDefault = SysConfig.getIndexConfig("timeSpacingDefaultParam");
            if(!filterTime(startTimeDefault))
            {
                LOG.error("配置文件开始时间格式错误,取默认配置,默认每天02:00:00刷新缓存!");
                startTimeDefault = START_TIME_DEFAULT;
            }
            if(!filterNumberHour(timeSpacingDefault))
            {
                LOG.error("配置文件时间间隔格式错误,取默认配置,默认刷新缓存时间间隔24小时!");
                timeSpacingDefault = TIME_SPACING_DEFAULT;
            }
            //timeSpacingDefault对应天数,period对应相应的毫秒数
            period = Integer.parseInt(timeSpacingDefault)* 24 * 60 * 60 * 1000;
            final SimpleDateFormat dateFormatter = new SimpleDateFormat("yyyy-MM-dd "+startTimeDefault);
            Date startTime = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(dateFormatter.format(new Date()));
            if(System.currentTimeMillis() > startTime.getTime())
            {
                startTime = new Date(startTime.getTime()+period);
                initialDelay = startTime.getTime()-System.currentTimeMillis();
            }
            else
            {
                initialDelay = startTime.getTime()-System.currentTimeMillis();
            }
        }
        catch (ParseException e)
        {
            LOG.error("定时任务在日期转换时出现错误!");
            LOG.error(e.getMessage());
        }
        catch (Exception e)
        {
            LOG.error(e.getMessage());
        }
        POOL.scheduleAtFixedRate(new Runnable()
        {
            @Override
            public void run()
            {
                loadParamConfig();
            }
        }, initialDelay, period, TimeUnit.MILLISECONDS);
    }
    对应正则表达式
        /**
     * 检测字符串是否为单个数值
     * @param str
     * @return [参数说明]
     * 
     * @return boolean [返回类型说明]
     * @exception throws [违例类型] [违例说明]
     * @see [类、类#方法、类#成员]
     */
    public static boolean filterNumberHour(String str)
    {
        String regEx = "[1-9]{1}[0-9]{0,}";//匹配含有1个或是多个数字的字符串,字符串不能是0或是以0开头
        Pattern pattern = Pattern.compile(regEx);
        Matcher matcher = pattern.matcher(str.trim());
        boolean rs = matcher.matches();
        return rs;
    }
    
    /**
     * 检测字符串是否为时间格式xx:xx:xx
     * @param str
     * @return [参数说明]
     * 
     * @return boolean [返回类型说明]
     * @exception throws [违例类型] [违例说明]
     * @see [类、类#方法、类#成员]
     */
    public static boolean filterTime(String str)
    {
        String regEx = "([01]\\d|2[0-3]):([0-5]\\d):([0-5]\\d)";//匹配时间格式的字符串
        Pattern pattern = Pattern.compile(regEx);
        Matcher matcher = pattern.matcher(str.trim());
        boolean rs = matcher.matches();
        return rs;
    }
    
    （2）正则表达式类
    
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexUtils
{
    public static String mergeBlank(String str)
    {
        //表示一个或多个空格的正则表达式
        String regex = "\\s+"; 
        
        String strMergeBlank = str.trim().replaceAll(regex, " ");
        
        return strMergeBlank;
    }
    
    public static boolean filterChineseBlankNumber(String str)
    {
        String regEx = "[\u4E00-\u9FA5]{1,}[\\s]{1,}[a-zA-Z0-9]{1,}[\\s\\S]*";//匹配中文汉字+空格+工号,如李颖姝 00426092
        Pattern pattern = Pattern.compile(regEx);
        Matcher matcher = pattern.matcher(str.trim());
        boolean rs = matcher.matches();
        return rs;
    }
    
    public static boolean filterPinyinBlankNumber(String str)
    {
        String regEx = "[a-zA-Z]{1,}[\\s]{1,}[a-zA-Z0-9]{1,}[\\s\\S]*";//匹配拼音+空格+工号,如liuxuan WX458995
        Pattern pattern = Pattern.compile(regEx);
        Matcher matcher = pattern.matcher(str.trim());
        boolean rs = matcher.matches();
        return rs;
    }

    public static boolean filterAnyCharacterAndComma(String str)
    {
        String regEx = "[\\s\\S]*[,]$";//匹配以逗号结尾的字符串
        Pattern pattern = Pattern.compile(regEx);
        Matcher matcher = pattern.matcher(str.trim());
        boolean rs = matcher.matches();
        return rs;
    }
    
    public static boolean filterHasComma(String str)
    {
        String regEx = "[\\s\\S]*[,][\\s\\S]*";//匹配含有逗号的字符串
        Pattern pattern = Pattern.compile(regEx);
        Matcher matcher = pattern.matcher(str.trim());
        boolean rs = matcher.matches();
        return rs;
    }
   
    public static boolean filterNumber(String str)
    {
        String regEx = "[0-9]{1,}";//匹配含有1个或是多个数字的字符串
        Pattern pattern = Pattern.compile(regEx);
        Matcher matcher = pattern.matcher(str.trim());
        boolean rs = matcher.matches();
        return rs;
    }
    
    public static boolean filterNumber2(String str)
    {
        String regEx = "[1-9]{1}[0-9]{0,}";//匹配含有1个或是多个数字的字符串
        Pattern pattern = Pattern.compile(regEx);
        Matcher matcher = pattern.matcher(str.trim());
        boolean rs = matcher.matches();
        return rs;
    }
    
    public static boolean filterTime(String str)
    {
        String regEx = "([01]\\d|2[0-3]):([0-5]\\d):([0-5]\\d)";//匹配时间格式的字符串
        Pattern pattern = Pattern.compile(regEx);
        Matcher matcher = pattern.matcher(str.trim());
        boolean rs = matcher.matches();
        return rs;
    }
    
    public static void main(String[] args)
    {
        boolean str = RegexUtils.filterTime("00:59:30");
        System.out.println("str:"+str);
    }
    
}

（1）mybatis查询clob数据
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.huawei.searchevaluate.dao.UserParamConfigDao">
	<resultMap type="UserParamConfig" id="UserParamConfig">
		<id property="id" column="ID" />
		<result property="type" column="TYPE" />
		<result property="rndCollection" column="RNDCOLLECTION" />
		<result property="param" column="PARAM" javaType="java.lang.String" jdbcType="CLOB"/>
	</resultMap>
	
	<select id="queryUserParamConfig" resultMap="UserParamConfig" >
		SELECT
		u.ID,
		u.TYPE,
		u.RNDCOLLECTION,
		u.PARAM
		FROM USER_PARAM_CONFIG u
		where 1 = 1
		<if test="type != null and type != ''">
			and u.TYPE = #{type}
		</if>
	</select>
</mapper>

import java.util.List;
import java.util.Map;

import com.huawei.searchevaluate.entity.UserParamConfig;


public interface UserParamConfigDao
{
    /**
     * 可配置查询框架参数配置
     * @param type
     * @return [参数说明]
     * 
     * @return List<UserParamConfig> [返回类型说明]
     * @exception throws [违例类型] [违例说明]
     * @see [类、类#方法、类#成员]
     */
    List<UserParamConfig> queryUserParamConfig(Map<String, Object> map);
}

(2)在springboot里面获取bean对象的工具类
@Component
public class ApplicationContextUtil implements ApplicationContextAware {
    private static ApplicationContext context;

    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        context = applicationContext;
    }
    
    public static ApplicationContext getApplicationContext() {
        return context;
    }
}

